import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage, type IStorage } from "./storage";
import { databaseStorage } from "./database";
import { insertAuditSchema, insertAiFixReportSchema } from "@shared/schema";

export async function registerRoutes(app: Express): Promise<Server> {
  // Initialize database storage and mock data
  let activeStorage: IStorage = storage; // Default to in-memory storage
  
  if (process.env.DATABASE_URL) {
    try {
      await databaseStorage.initializeMockData();
      if (databaseStorage.isAvailable()) {
        activeStorage = databaseStorage as IStorage;
        console.log('Using database storage');
      } else {
        console.log('Database not available, using in-memory storage');
      }
    } catch (error) {
      console.log('Database initialization failed, using in-memory storage:', error);
    }
  } else {
    console.log('DATABASE_URL not provided, using in-memory storage');
  }

  // GitHub OAuth simulation endpoints
  app.get("/api/login", (req, res) => {
    // In a real implementation, this would redirect to GitHub OAuth
    // For demo purposes, we'll just redirect to dashboard
    res.redirect('/dashboard');
  });

  app.get("/api/logout", (req, res) => {
    // Clear session and redirect to home
    res.redirect('/');
  });

  // Get current user (mock user for demo)
  app.get("/api/user", async (req, res) => {
    const user = await activeStorage.getUser(1); // Mock user ID 1
    res.json(user);
  });

  // Get repositories for current user
  app.get("/api/repositories", async (req, res) => {
    const repositories = await activeStorage.getRepositories(1); // Mock user ID 1
    res.json(repositories);
  });

  // Run audit on selected repositories
  app.post("/api/audit", async (req, res) => {
    const { repositoryIds } = req.body;
    
    const results = [];
    for (const repositoryId of repositoryIds) {
      // Mock audit results
      const mockIssues = [
        { error: "Missing meta description", file: "pages/index.js", line: 12, severity: "critical" },
        { error: "Title too short", file: "pages/about.js", line: 8, severity: "critical" },
        { error: "Missing alt text", file: "components/Hero.js", line: 24, severity: "warning" },
      ];
      
      const audit = await activeStorage.createAudit({
        repositoryId,
        userId: 1,
        score: Math.floor(Math.random() * 40) + 60, // Random score between 60-100
        issues: mockIssues,
        status: "complete",
      });
      
      results.push(audit);
    }
    
    res.json(results);
  });

  // Generate AI fixes for audit
  app.post("/api/ai-fix", async (req, res) => {
    const { auditId } = req.body;
    
    const mockFixes = [
      {
        title: "Meta Description",
        description: "Add this meta description to your index.js file:",
        code: '<meta name="description" content="Professional portfolio showcasing modern web development projects and skills" />',
        file: "pages/index.js"
      },
      {
        title: "Title Optimization",
        description: "Update your about page title:",
        code: '<title>About John Doe - Full Stack Developer | Portfolio</title>',
        file: "pages/about.js"
      },
      {
        title: "Alt Text",
        description: "Add descriptive alt text to your hero image:",
        code: '<img src="hero.jpg" alt="Professional headshot of John Doe, web developer" />',
        file: "components/Hero.js"
      }
    ];
    
    const aiFixReport = await activeStorage.createAiFixReport({
      auditId,
      fixes: mockFixes,
      status: "generated",
    });
    
    res.json(aiFixReport);
  });

  // Get audit history
  app.get("/api/audits", async (req, res) => {
    const audits = await activeStorage.getAudits(1); // Mock user ID 1
    res.json(audits);
  });

  // Download audit report as markdown
  app.get("/api/download/audit/:id", async (req, res) => {
    const auditId = parseInt(req.params.id);
    const audit = await activeStorage.getAuditById(auditId);
    
    if (!audit) {
      return res.status(404).json({ error: "Audit not found" });
    }
    
    const repositories = await activeStorage.getAllRepositories();
    const repo = repositories.find((r: any) => r.id === audit.repositoryId);
    const issues = audit.issues as any[] || [];
    
    const markdown = `# SEO Audit Report
    
## Repository: ${repo?.name || 'Unknown'}
**Date:** ${audit.createdAt?.toLocaleDateString() || 'Unknown'}
**Score:** ${audit.score || 0}%
**Status:** ${audit.status || 'Unknown'}

## Issues Found (${issues.length})

${issues.map((issue: any, index: number) => `
### ${index + 1}. ${issue.error}
- **File:** ${issue.file}
- **Line:** ${issue.line}
- **Severity:** ${issue.severity}
`).join('\n')}

---
Generated by Crawlin.io SEO Audit Tool
`;
    
    res.setHeader('Content-Type', 'text/markdown');
    res.setHeader('Content-Disposition', `attachment; filename="audit-${repo?.name || 'unknown'}-${audit.id}.md"`);
    res.send(markdown);
  });

  // Download AI fix report as markdown
  app.get("/api/download/fix/:id", async (req, res) => {
    const fixId = parseInt(req.params.id);
    const fixReport = await activeStorage.getAiFixReportById(fixId);
    
    if (!fixReport) {
      return res.status(404).json({ error: "Fix report not found" });
    }
    
    const allAudits = await activeStorage.getAllAudits();
    const audit = allAudits.find((a: any) => a.id === fixReport.auditId);
    const repositories = await activeStorage.getAllRepositories();
    const repo = audit ? repositories.find((r: any) => r.id === audit.repositoryId) : null;
    const fixes = fixReport.fixes as any[] || [];
    
    const markdown = `# AI Fix Report
    
## Repository: ${repo?.name || 'Unknown'}
**Date:** ${fixReport.appliedAt?.toLocaleDateString() || 'Unknown'}
**Status:** ${fixReport.status || 'Unknown'}
**Audit Score:** ${audit?.score || 0}%

## AI-Generated Fixes (${fixes.length})

${fixes.map((fix: any, index: number) => `
### ${index + 1}. ${fix.title}

**Description:** ${fix.description}

**File:** ${fix.file}

**Code:**
\`\`\`html
${fix.code}
\`\`\`
`).join('\n')}

---
Generated by Crawlin.io AI Fix Tool
`;
    
    res.setHeader('Content-Type', 'text/markdown');
    res.setHeader('Content-Disposition', `attachment; filename="fix-${repo?.name || 'unknown'}-${fixReport.id}.md"`);
    res.send(markdown);
  });

  // Get combined history data
  app.get("/api/history", async (req, res) => {
    const audits = await activeStorage.getAllAudits();
    const fixReports = await activeStorage.getAllAiFixReports();
    const repositories = await activeStorage.getAllRepositories();
    
    const historyItems = [
      ...audits.map((audit: any) => {
        const repo = repositories.find((r: any) => r.id === audit.repositoryId);
        const issues = audit.issues as any[] || [];
        const criticalCount = issues.filter((i: any) => i.severity === 'critical').length;
        const warningCount = issues.filter((i: any) => i.severity === 'warning').length;
        
        return {
          id: `audit-${audit.id}`,
          auditId: audit.id,
          date: audit.createdAt?.toLocaleString() || 'Unknown',
          action: 'Audit',
          repository: repo?.name || 'Unknown',
          status: audit.status || 'Unknown',
          issues: criticalCount > 0 ? `${criticalCount} critical${warningCount > 0 ? `, ${warningCount} warnings` : ''}` : 
                  warningCount > 0 ? `${warningCount} warnings` : 'No issues',
          score: audit.score || 0,
          type: 'audit'
        };
      }),
      ...fixReports.map((fix: any) => {
        const audit = audits.find((a: any) => a.id === fix.auditId);
        const repo = audit ? repositories.find((r: any) => r.id === audit.repositoryId) : null;
        const fixes = fix.fixes as any[] || [];
        
        return {
          id: `fix-${fix.id}`,
          fixId: fix.id,
          date: fix.appliedAt?.toLocaleString() || 'Unknown',
          action: 'Fix',
          repository: repo?.name || 'Unknown',
          status: fix.status || 'Unknown',
          issues: `${fixes.length} fixes generated`,
          score: audit?.score || 0,
          type: 'fix'
        };
      })
    ].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    
    res.json(historyItems);
  });

  // Get reports data
  app.get("/api/reports", async (req, res) => {
    const mockReportsData = {
      kpis: {
        overallScore: 87,
        scoreChange: 12,
        criticalIssues: 3,
        issuesChange: -2,
        totalAudits: 156,
        auditsChange: 23,
        repositories: 12
      },
      chartData: {
        seoScoreOverTime: [
          { month: "Jul", score: 75 },
          { month: "Aug", score: 78 },
          { month: "Sep", score: 82 },
          { month: "Oct", score: 85 },
          { month: "Nov", score: 84 },
          { month: "Dec", score: 87 }
        ],
        issuesBreakdown: [
          { type: "Critical", count: 3 },
          { type: "Warnings", count: 8 }
        ]
      },
      recentAudits: [
        { id: 1, repository: "portfolio-site", date: "2024-01-15", score: 92, issues: "2 critical", status: "In Progress" },
        { id: 2, repository: "ecommerce-app", date: "2024-01-14", score: 78, issues: "5 warnings", status: "Fixed" },
        { id: 3, repository: "blog-platform", date: "2024-01-13", score: 95, issues: "No issues", status: "Complete" },
        { id: 4, repository: "company-website", date: "2024-01-12", score: 65, issues: "8 critical", status: "Failed" },
        { id: 5, repository: "api-service", date: "2024-01-11", score: 88, issues: "3 warnings", status: "Fixed" }
      ]
    };
    
    res.json(mockReportsData);
  });

  const httpServer = createServer(app);
  return httpServer;
}
